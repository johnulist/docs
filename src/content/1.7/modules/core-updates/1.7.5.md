---
title: Changes in PrestaShop 1.7.5
menuTitle: Changes in 1.7.5
aliases:
    - /1.7/modules/core_updates/1.7.5/
---

# Notable changes in PrestaShop 1.7.5

## LazyArrays

Starting with PrestaShop 1.7.5, the business objects (Product, Order...) available on the front-office are `LazyArray` instances. If your module relies on data available in the hook parameters or in the template, you may be concerned by this update.

They used to be `arrays` with all the data available. This change has been introduced to load the needed properties of an object only when requested, and globally improve the performance of the front-office.

Getting properties from the object should not change between first versions of PS 1.7 and 1.7.5.

However it appeared that some modules, especially the ones with a large compatibility range like PrestaShop 1.6 & 1.7, apply an array cast when the variable in not an array. **Casting these variables as arrays on PS 1.7.5+ will throw notices when getting their properties.**


|    | 1.6 | 1.7.0+ | 1.7.5+ |
|----|-----|--------|--------|
| Variable type / class | `ObjectModel` | `array` | `PrestaShop\PrestaShop\Adapter\Presenter\AbstractLazyArray` |
| Getting a property | `{(array)$var}['id']` or `$var->id` | `$var['id']` | `$var['id']` or `$var->id` |

Applying an `(array)` cast is valid only when you have a `ObjectModel` instance, for instance `Product`. Otherwise, you already have an array-compliant variable.

```php
<?php
public function hookdisplayFooterProduct($params)
{
    /*
     * Depending on the PrestaShop you run, the $product type won't be the same.
     * On PrestaShop 1.7, it can be directly used as an array.
     * 
     * However, if the module is also compatible with PrestaShop 1.6, 1.5...
     * an ObjectModel class will be returned.
     * Casting it as an array *in this specific situation* will allow to cover all cases.
     */
    $product = $params['product'];
    if ($product instanceof Product /* or ObjectModel */) {
        $product = (array) $product;
    }

    // Getting product details.
    echo $product['id'];
}
```

**Links:**

* [Related issue on module Google Analytics (GitHub)](https://github.com/PrestaShop/ps_googleanalytics/pull/14/files)

## Automated link generation

PrestaShop now automatically converts links generated by `Link::getAdminLink()` calls into links to the newly migrated Symfony pages. This means that if you used this method somewhere in your modules to link to a page that has since been migrated, PrestaShop will automatically "upgrade" it so that it points to the new Symfony-style URL.

With this change, module developers no longer need to update their links each time a page is migrated. However in many places the method is not used with URL parameters as arguments, and parameters are concatenated as a string after the `getAdminLink` call instead. This can result in wrong conversion use cases, so you might need to refactor the way you use this method.

Example:

```php
<?php
    // Code compliant from PrestaShop 1.5 to 1.7.4
    $link->getAdminLink('AdminOrders') . '&amp;id_order={$order->id|intval}&amp;vieworder';

    // Recommended code from PrestaShop 1.7.5
    $link->getAdminLink('AdminOrders', true, [], ['id_customer' => $customer->id|intval, 'viewcustomer' => 1]);

    // If you need to be compatible from 1.5 to the latest 1.7 version, then you can combine both styles
    $link->getAdminLink('AdminOrders', true, [], ['id_customer' => $customer->id|intval, 'viewcustomer' => 1]) . '&amp;id_order={$order->id|intval}&amp;vieworder';
```

Although this won't be a problem for legacy controllers, if it's not used properly, the generated link won't work anymore once the page is migrated to Symfony. We recommend refactoring your calls to `getAdminLink` beforehand.

You can find more details about this new feature in the [Controller and Routing][controller-routing] page. 

[controller-routing]: {{< ref "/1.7/development/architecture/migration-guide/controller-routing.md#the-legacy-link-property" >}}
